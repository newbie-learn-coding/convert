// src/generated/events.generated.ts
var WORD = 64;
var DWORD = 128;
var TEXT = 192;
var DATA = 208;
var NEW_TEXT_IDS = [
  TEXT + 49,
  // ArrangementID.Name
  TEXT + 39,
  // DisplayGroupID.Name
  TEXT + 47
  // TrackID.Name
];
var EVENT_ID = {
  // === Project IDs (from project.py) ===
  PROJECT_LOOP_ACTIVE: 9,
  PROJECT_SHOW_INFO: 10,
  PROJECT__VOLUME: 12,
  PROJECT_PAN_LAW: 23,
  PROJECT_LICENSED: 28,
  PROJECT__TEMPO_COARSE: WORD + 2,
  // 66
  PROJECT_PITCH: WORD + 16,
  // 80
  PROJECT__TEMPO_FINE: WORD + 29,
  // 93
  PROJECT_CUR_GROUP_ID: DWORD + 18,
  PROJECT_TEMPO: DWORD + 28,
  PROJECT_FL_BUILD: DWORD + 31,
  PROJECT_TITLE: TEXT + 2,
  // 194
  PROJECT_COMMENTS: TEXT + 3,
  // 195
  PROJECT_URL: TEXT + 5,
  // 197
  PROJECT__RTF_COMMENTS: TEXT + 6,
  // 198
  PROJECT_FL_VERSION: TEXT + 7,
  // 199
  PROJECT_LICENSEE: TEXT + 8,
  // 200
  PROJECT_DATA_PATH: TEXT + 10,
  // 202
  PROJECT_GENRE: TEXT + 14,
  // 206
  PROJECT_ARTISTS: TEXT + 15,
  // 207
  PROJECT_TIMESTAMP: DATA + 29,
  // 237
  // === Channel IDs (from channel.py) ===
  CHANNEL_IS_ENABLED: 0,
  CHANNEL__VOL_BYTE: 2,
  CHANNEL__PAN_BYTE: 3,
  CHANNEL_ZIPPED: 15,
  CHANNEL_PING_PONG_LOOP: 20,
  CHANNEL_TYPE: 21,
  CHANNEL_ROUTED_TO: 22,
  CHANNEL_IS_LOCKED: 32,
  CHANNEL_NEW: WORD,
  CHANNEL_FREQ_TILT: WORD + 5,
  // 69
  CHANNEL_FX_FLAGS: WORD + 6,
  // 70
  CHANNEL_CUTOFF: WORD + 7,
  // 71
  CHANNEL__VOL_WORD: WORD + 8,
  // 72
  CHANNEL__PAN_WORD: WORD + 9,
  // 73
  CHANNEL_PREAMP: WORD + 10,
  // 74
  CHANNEL_FADE_OUT: WORD + 11,
  // 75
  CHANNEL_FADE_IN: WORD + 12,
  // 76
  CHANNEL_RESONANCE: WORD + 19,
  // 83
  CHANNEL_STEREO_DELAY: WORD + 21,
  // 85
  CHANNEL_POGO: WORD + 22,
  // 86
  CHANNEL_TIME_SHIFT: WORD + 25,
  // 89
  CHANNEL_CHILDREN: WORD + 30,
  // 94
  CHANNEL_SWING: WORD + 33,
  // 97
  CHANNEL_RING_MOD: DWORD + 3,
  CHANNEL_CUT_GROUP: DWORD + 4,
  CHANNEL_ROOT_NOTE: DWORD + 7,
  CHANNEL_DELAY_MOD_XY: DWORD + 10,
  CHANNEL_REVERB: DWORD + 11,
  CHANNEL__STRETCH_TIME: DWORD + 12,
  CHANNEL_FINE_TUNE: DWORD + 14,
  CHANNEL_SAMPLER_FLAGS: DWORD + 15,
  CHANNEL_LAYER_FLAGS: DWORD + 16,
  CHANNEL_GROUP_NUM: DWORD + 17,
  CHANNEL_AU_SAMPLE_RATE: DWORD + 25,
  CHANNEL__NAME: TEXT,
  CHANNEL_SAMPLE_PATH: TEXT + 4,
  // 196
  CHANNEL_DELAY: DATA + 1,
  // 209
  CHANNEL_PARAMETERS: DATA + 7,
  // 215
  CHANNEL_ENVELOPE_LFO: DATA + 10,
  // 218
  CHANNEL_LEVELS: DATA + 11,
  // 219
  CHANNEL_POLYPHONY: DATA + 13,
  // 221
  CHANNEL_TRACKING: DATA + 20,
  // 228
  CHANNEL_LEVEL_ADJUSTS: DATA + 21,
  // 229
  CHANNEL_AUTOMATION: DATA + 26,
  // 234
  // === Plugin IDs (from plugin.py) ===
  PLUGIN_COLOR: DWORD,
  PLUGIN_ICON: DWORD + 27,
  PLUGIN_INTERNAL_NAME: TEXT + 9,
  // 201
  PLUGIN_NAME: TEXT + 11,
  // 203
  PLUGIN_WRAPPER: DATA + 4,
  // 212
  PLUGIN_DATA: DATA + 5,
  // 213
  // === Display Group IDs ===
  DISPLAY_GROUP_NAME: TEXT + 39,
  // 231
  // === Rack IDs ===
  RACK_SWING: 11,
  RACK__FIT_TO_STEPS: 13,
  RACK_WINDOW_HEIGHT: DWORD + 5,
  // === Mixer IDs (from mixer.py) ===
  MIXER_SLOT_INDEX: WORD + 34,
  // 98
  MIXER_INSERT_ICON: WORD + 31,
  // 95
  MIXER_INSERT_OUTPUT: DWORD + 19,
  MIXER_INSERT_COLOR: DWORD + 21,
  MIXER_INSERT_INPUT: DWORD + 26,
  MIXER_INSERT_NAME: TEXT + 12,
  // 204
  MIXER_INSERT_ROUTING: DATA + 27,
  // 235
  MIXER_INSERT_FLAGS: DATA + 28
  // 236
};
var EVENT_KIND = {
  // Project events
  [EVENT_ID.PROJECT_LOOP_ACTIVE]: "u8",
  [EVENT_ID.PROJECT_SHOW_INFO]: "u8",
  [EVENT_ID.PROJECT__VOLUME]: "u8",
  [EVENT_ID.PROJECT_PAN_LAW]: "u8",
  [EVENT_ID.PROJECT_LICENSED]: "u8",
  [EVENT_ID.PROJECT__TEMPO_COARSE]: "u16",
  [EVENT_ID.PROJECT_PITCH]: "i16",
  [EVENT_ID.PROJECT__TEMPO_FINE]: "u16",
  [EVENT_ID.PROJECT_CUR_GROUP_ID]: "i32",
  [EVENT_ID.PROJECT_TEMPO]: "u32",
  [EVENT_ID.PROJECT_FL_BUILD]: "u32",
  [EVENT_ID.PROJECT_TITLE]: "text",
  [EVENT_ID.PROJECT_COMMENTS]: "text",
  [EVENT_ID.PROJECT_URL]: "text",
  [EVENT_ID.PROJECT__RTF_COMMENTS]: "text",
  [EVENT_ID.PROJECT_FL_VERSION]: "text",
  [EVENT_ID.PROJECT_LICENSEE]: "text",
  [EVENT_ID.PROJECT_DATA_PATH]: "text",
  [EVENT_ID.PROJECT_GENRE]: "text",
  [EVENT_ID.PROJECT_ARTISTS]: "text",
  [EVENT_ID.PROJECT_TIMESTAMP]: "data",
  // Channel events
  [EVENT_ID.CHANNEL_IS_ENABLED]: "u8",
  [EVENT_ID.CHANNEL__VOL_BYTE]: "u8",
  [EVENT_ID.CHANNEL__PAN_BYTE]: "u8",
  [EVENT_ID.CHANNEL_ZIPPED]: "u8",
  [EVENT_ID.CHANNEL_PING_PONG_LOOP]: "u8",
  [EVENT_ID.CHANNEL_TYPE]: "u8",
  [EVENT_ID.CHANNEL_ROUTED_TO]: "i8",
  [EVENT_ID.CHANNEL_IS_LOCKED]: "u8",
  [EVENT_ID.CHANNEL_NEW]: "u16",
  [EVENT_ID.CHANNEL_FREQ_TILT]: "u16",
  [EVENT_ID.CHANNEL_FX_FLAGS]: "u16",
  [EVENT_ID.CHANNEL_CUTOFF]: "u16",
  [EVENT_ID.CHANNEL__VOL_WORD]: "u16",
  [EVENT_ID.CHANNEL__PAN_WORD]: "u16",
  [EVENT_ID.CHANNEL_PREAMP]: "u16",
  [EVENT_ID.CHANNEL_FADE_OUT]: "u16",
  [EVENT_ID.CHANNEL_FADE_IN]: "u16",
  [EVENT_ID.CHANNEL_RESONANCE]: "u16",
  [EVENT_ID.CHANNEL_STEREO_DELAY]: "u16",
  [EVENT_ID.CHANNEL_POGO]: "u16",
  [EVENT_ID.CHANNEL_TIME_SHIFT]: "u16",
  [EVENT_ID.CHANNEL_CHILDREN]: "u16",
  [EVENT_ID.CHANNEL_SWING]: "u16",
  [EVENT_ID.CHANNEL_RING_MOD]: "u32",
  [EVENT_ID.CHANNEL_CUT_GROUP]: "u32",
  [EVENT_ID.CHANNEL_ROOT_NOTE]: "u32",
  [EVENT_ID.CHANNEL_DELAY_MOD_XY]: "u32",
  [EVENT_ID.CHANNEL_REVERB]: "u32",
  [EVENT_ID.CHANNEL__STRETCH_TIME]: "f32",
  [EVENT_ID.CHANNEL_FINE_TUNE]: "i32",
  [EVENT_ID.CHANNEL_SAMPLER_FLAGS]: "u32",
  [EVENT_ID.CHANNEL_LAYER_FLAGS]: "u32",
  [EVENT_ID.CHANNEL_GROUP_NUM]: "i32",
  [EVENT_ID.CHANNEL_AU_SAMPLE_RATE]: "u32",
  [EVENT_ID.CHANNEL__NAME]: "text",
  [EVENT_ID.CHANNEL_SAMPLE_PATH]: "text",
  [EVENT_ID.CHANNEL_DELAY]: "data",
  [EVENT_ID.CHANNEL_PARAMETERS]: "data",
  [EVENT_ID.CHANNEL_ENVELOPE_LFO]: "data",
  [EVENT_ID.CHANNEL_LEVELS]: "data",
  [EVENT_ID.CHANNEL_POLYPHONY]: "data",
  [EVENT_ID.CHANNEL_TRACKING]: "data",
  [EVENT_ID.CHANNEL_LEVEL_ADJUSTS]: "data",
  [EVENT_ID.CHANNEL_AUTOMATION]: "data",
  // Plugin events
  [EVENT_ID.PLUGIN_COLOR]: "u32",
  [EVENT_ID.PLUGIN_ICON]: "u32",
  [EVENT_ID.PLUGIN_INTERNAL_NAME]: "text",
  [EVENT_ID.PLUGIN_NAME]: "text",
  [EVENT_ID.PLUGIN_WRAPPER]: "data",
  [EVENT_ID.PLUGIN_DATA]: "data",
  // Display Group events
  [EVENT_ID.DISPLAY_GROUP_NAME]: "data",
  // Rack events
  [EVENT_ID.RACK_SWING]: "u8",
  [EVENT_ID.RACK__FIT_TO_STEPS]: "u8",
  [EVENT_ID.RACK_WINDOW_HEIGHT]: "u32",
  // Mixer events
  [EVENT_ID.MIXER_SLOT_INDEX]: "u16",
  [EVENT_ID.MIXER_INSERT_ICON]: "i16",
  [EVENT_ID.MIXER_INSERT_OUTPUT]: "i32",
  [EVENT_ID.MIXER_INSERT_COLOR]: "u32",
  [EVENT_ID.MIXER_INSERT_INPUT]: "i32",
  [EVENT_ID.MIXER_INSERT_NAME]: "text",
  [EVENT_ID.MIXER_INSERT_ROUTING]: "data",
  [EVENT_ID.MIXER_INSERT_FLAGS]: "data"
};
function getEventKind(eventId) {
  const mapped = EVENT_KIND[eventId];
  if (mapped !== void 0) {
    return mapped;
  }
  if (eventId < WORD) {
    return "u8";
  } else if (eventId < DWORD) {
    return "u16";
  } else if (eventId < TEXT) {
    return "u32";
  } else if (eventId < DATA || NEW_TEXT_IDS.includes(eventId)) {
    return "text";
  } else {
    return "data";
  }
}
function getEventFixedSize(eventId) {
  if (eventId < WORD) {
    return 1;
  } else if (eventId < DWORD) {
    return 2;
  } else if (eventId < TEXT) {
    return 4;
  }
  return -1;
}

// src/io/BinaryReader.ts
import * as protobuf from "protobufjs/minimal.js";
import { SmartBuffer } from "smart-buffer";
var BinaryReader = class {
  sb;
  constructor(buffer) {
    this.sb = SmartBuffer.fromBuffer(buffer);
  }
  /**
   * Returns current read position
   */
  tell() {
    return this.sb.readOffset;
  }
  /**
   * Seeks to an absolute position
   */
  seek(pos) {
    this.sb.readOffset = pos;
  }
  /**
   * Seeks relative to current position
   */
  skip(offset) {
    this.sb.readOffset += offset;
  }
  /**
   * Returns total buffer length
   */
  length() {
    return this.sb.length;
  }
  /**
   * Returns remaining bytes to read
   */
  remaining() {
    return this.sb.remaining();
  }
  /**
   * Returns true if there are more bytes to read
   */
  hasMore() {
    return this.sb.remaining() > 0;
  }
  /**
   * Reads an unsigned 8-bit integer
   */
  readU8() {
    return this.sb.readUInt8();
  }
  /**
   * Reads a signed 8-bit integer
   */
  readI8() {
    return this.sb.readInt8();
  }
  /**
   * Reads an unsigned 16-bit integer (little-endian)
   */
  readU16LE() {
    return this.sb.readUInt16LE();
  }
  /**
   * Reads a signed 16-bit integer (little-endian)
   */
  readI16LE() {
    return this.sb.readInt16LE();
  }
  /**
   * Reads an unsigned 32-bit integer (little-endian)
   */
  readU32LE() {
    return this.sb.readUInt32LE();
  }
  /**
   * Reads a signed 32-bit integer (little-endian)
   */
  readI32LE() {
    return this.sb.readInt32LE();
  }
  /**
   * Reads a 32-bit float (little-endian)
   */
  readF32LE() {
    return this.sb.readFloatLE();
  }
  /**
   * Reads a 64-bit float (little-endian)
   */
  readF64LE() {
    return this.sb.readDoubleLE();
  }
  /**
   * Reads raw bytes
   */
  readBytes(length) {
    return this.sb.readBuffer(length);
  }
  /**
   * Reads a VarInt (variable-length integer) using protobufjs
   * FL Studio uses this encoding for TEXT and DATA event sizes
   */
  readVarInt() {
    const remainingBuffer = this.sb.toBuffer().subarray(this.sb.readOffset);
    const reader = protobuf.Reader.create(remainingBuffer);
    const value = reader.uint32();
    this.sb.readOffset += reader.pos;
    return value;
  }
  /**
   * Reads an ASCII string (null-terminated)
   */
  readAsciiString(length) {
    const str = this.sb.readString(length, "ascii");
    const nullPos = str.indexOf("\0");
    return nullPos === -1 ? str : str.substring(0, nullPos);
  }
  /**
   * Reads a UTF-16LE string (null-terminated)
   */
  readUtf16LEString(length) {
    const bytes = this.sb.readBuffer(length);
    const str = bytes.toString("utf16le");
    const nullPos = str.indexOf("\0");
    return nullPos === -1 ? str : str.substring(0, nullPos);
  }
  /**
   * Peeks at bytes without advancing position
   */
  peek(length) {
    const pos = this.sb.readOffset;
    const data = this.sb.readBuffer(length);
    this.sb.readOffset = pos;
    return data;
  }
  /**
   * Peeks at a single byte without advancing position
   */
  peekU8() {
    const pos = this.sb.readOffset;
    const value = this.sb.readUInt8();
    this.sb.readOffset = pos;
    return value;
  }
  /**
   * Returns the internal buffer
   */
  toBuffer() {
    return this.sb.toBuffer();
  }
};

// src/io/BinaryWriter.ts
import { SmartBuffer as SmartBuffer2 } from "smart-buffer";
import * as protobuf2 from "protobufjs/minimal.js";
var BinaryWriter = class {
  sb;
  constructor() {
    this.sb = new SmartBuffer2();
  }
  /**
   * Returns current write position (total bytes written)
   */
  tell() {
    return this.sb.writeOffset;
  }
  /**
   * Writes an unsigned 8-bit integer
   */
  writeU8(value) {
    this.sb.writeUInt8(value & 255);
  }
  /**
   * Writes a signed 8-bit integer
   */
  writeI8(value) {
    this.sb.writeInt8(value);
  }
  /**
   * Writes an unsigned 16-bit integer (little-endian)
   */
  writeU16LE(value) {
    this.sb.writeUInt16LE(value & 65535);
  }
  /**
   * Writes a signed 16-bit integer (little-endian)
   */
  writeI16LE(value) {
    this.sb.writeInt16LE(value);
  }
  /**
   * Writes an unsigned 32-bit integer (little-endian)
   */
  writeU32LE(value) {
    this.sb.writeUInt32LE(value >>> 0);
  }
  /**
   * Writes a signed 32-bit integer (little-endian)
   */
  writeI32LE(value) {
    this.sb.writeInt32LE(value);
  }
  /**
   * Writes a 32-bit float (little-endian)
   */
  writeF32LE(value) {
    this.sb.writeFloatLE(value);
  }
  /**
   * Writes a 64-bit float (little-endian)
   */
  writeF64LE(value) {
    this.sb.writeDoubleLE(value);
  }
  /**
   * Writes raw bytes
   */
  writeBytes(data) {
    this.sb.writeBuffer(data);
  }
  /**
   * Writes a VarInt (variable-length integer) using protobufjs
   * FL Studio uses this encoding for TEXT and DATA event sizes
   */
  writeVarInt(value) {
    const writer = protobuf2.Writer.create();
    writer.uint32(value);
    const encoded = writer.finish();
    this.sb.writeBuffer(Buffer.from(encoded));
  }
  /**
   * Writes an ASCII string (null-terminated)
   */
  writeAsciiString(str) {
    this.sb.writeString(str + "\0", "ascii");
  }
  /**
   * Writes a UTF-16LE string (null-terminated)
   */
  writeUtf16LEString(str) {
    const buf = Buffer.from(str + "\0", "utf16le");
    this.sb.writeBuffer(buf);
  }
  /**
   * Gets the final buffer
   */
  toBuffer() {
    return this.sb.toBuffer();
  }
};
function encodeVarInt(value) {
  const writer = protobuf2.Writer.create();
  writer.uint32(value);
  return Buffer.from(writer.finish());
}
function varIntSize(value) {
  if (value < 128) return 1;
  if (value < 16384) return 2;
  if (value < 2097152) return 3;
  if (value < 268435456) return 4;
  return 5;
}

// src/parser/FlpParser.ts
var FLP_HEADER_MAGIC = "FLhd";
var FLP_DATA_MAGIC = "FLdt";
var FLP_HEADER_SIZE = 6;
function parseFlp(buffer) {
  const reader = new BinaryReader(buffer);
  const headerMagic = reader.readBytes(4).toString("ascii");
  if (headerMagic !== FLP_HEADER_MAGIC) {
    throw new Error(`Invalid header magic: expected 'FLhd', got '${headerMagic}'`);
  }
  const headerSize = reader.readU32LE();
  if (headerSize !== FLP_HEADER_SIZE) {
    throw new Error(`Invalid header size: expected ${FLP_HEADER_SIZE}, got ${headerSize}`);
  }
  const format = reader.readI16LE();
  const channelCount = reader.readU16LE();
  const ppq = reader.readU16LE();
  if (format < -1 || format > 80) {
    throw new Error(`Invalid file format: ${format}`);
  }
  const headerChunkBytes = buffer.subarray(0, 14);
  const dataMagic = reader.readBytes(4).toString("ascii");
  if (dataMagic !== FLP_DATA_MAGIC) {
    throw new Error(`Invalid data magic: expected 'FLdt', got '${dataMagic}'`);
  }
  const eventsSize = reader.readU32LE();
  const expectedFileSize = 22 + eventsSize;
  if (buffer.length !== expectedFileSize) {
    throw new Error(
      `Data chunk size mismatch: expected file size ${expectedFileSize}, got ${buffer.length}`
    );
  }
  const fldtHeaderBytes = buffer.subarray(14, 22);
  const events = [];
  let flVersion = "0.0.0";
  let useUnicode = false;
  const eventsStart = reader.tell();
  const eventsEnd = eventsStart + eventsSize;
  while (reader.tell() < eventsEnd) {
    const eventStart = reader.tell();
    const eventId = reader.readU8();
    let payloadSize;
    let headerSize2;
    if (eventId < WORD) {
      payloadSize = 1;
      headerSize2 = 1;
    } else if (eventId < DWORD) {
      payloadSize = 2;
      headerSize2 = 1;
    } else if (eventId < TEXT) {
      payloadSize = 4;
      headerSize2 = 1;
    } else {
      const sizeStart = reader.tell();
      payloadSize = reader.readVarInt();
      headerSize2 = 1 + (reader.tell() - sizeStart);
    }
    const payload = reader.readBytes(payloadSize);
    const header = buffer.subarray(eventStart, eventStart + headerSize2);
    const kind = getEventKind(eventId);
    const event = {
      id: eventId,
      kind,
      header: Buffer.from(header),
      payload: Buffer.from(payload)
    };
    events.push(event);
    if (eventId === EVENT_ID.PROJECT_FL_VERSION) {
      flVersion = payload.toString("ascii").replace(/\0/g, "");
      const parts = flVersion.split(".").map((p) => parseInt(p, 10));
      const major = parts[0] ?? 0;
      const minor = parts[1] ?? 0;
      useUnicode = parts.length >= 2 && (major > 11 || major === 11 && minor >= 5);
    }
  }
  let trailingBytes;
  if (reader.remaining() > 0) {
    trailingBytes = reader.readBytes(reader.remaining());
  }
  return {
    headerChunkBytes: Buffer.from(headerChunkBytes),
    fldtHeaderBytes: Buffer.from(fldtHeaderBytes),
    events,
    trailingBytes,
    flVersion,
    useUnicode
  };
}
function serializeFlp(parsed) {
  const writer = new BinaryWriter();
  writer.writeBytes(parsed.headerChunkBytes);
  let eventsSize = 0;
  for (const event of parsed.events) {
    eventsSize += serializeEvent(event).length;
  }
  if (parsed.trailingBytes) {
    eventsSize += parsed.trailingBytes.length;
  }
  writer.writeBytes(Buffer.from(FLP_DATA_MAGIC, "ascii"));
  writer.writeU32LE(eventsSize);
  for (const event of parsed.events) {
    writer.writeBytes(serializeEvent(event));
  }
  if (parsed.trailingBytes) {
    writer.writeBytes(parsed.trailingBytes);
  }
  return writer.toBuffer();
}
function serializeEvent(event) {
  const writer = new BinaryWriter();
  writer.writeU8(event.id);
  if (event.id >= TEXT) {
    writer.writeVarInt(event.payload.length);
  }
  writer.writeBytes(event.payload);
  return writer.toBuffer();
}
function createEvent(id, payload) {
  const kind = getEventKind(id);
  const headerWriter = new BinaryWriter();
  headerWriter.writeU8(id);
  if (id >= TEXT) {
    headerWriter.writeVarInt(payload.length);
  }
  return {
    id,
    kind,
    header: headerWriter.toBuffer(),
    payload: Buffer.from(payload)
  };
}
function patchEvents(parsed, patcher) {
  const patchedEvents = parsed.events.map((event, index) => {
    const patched = patcher(event, index);
    if (patched.payload !== event.payload && patched.id >= TEXT) {
      const headerWriter = new BinaryWriter();
      headerWriter.writeU8(patched.id);
      headerWriter.writeVarInt(patched.payload.length);
      return {
        ...patched,
        header: headerWriter.toBuffer()
      };
    }
    return patched;
  });
  return {
    ...parsed,
    events: patchedEvents
  };
}
function findEvents(parsed, eventId) {
  return parsed.events.filter((e) => e.id === eventId);
}
function findFirstEvent(parsed, eventId) {
  return parsed.events.find((e) => e.id === eventId);
}
function getEventString(event, useUnicode) {
  if (event.kind !== "text") {
    throw new Error(`Event ${event.id} is not a text event`);
  }
  if (useUnicode) {
    const str = event.payload.toString("utf16le");
    const nullPos = str.indexOf("\0");
    return nullPos === -1 ? str : str.substring(0, nullPos);
  } else {
    const str = event.payload.toString("ascii");
    const nullPos = str.indexOf("\0");
    return nullPos === -1 ? str : str.substring(0, nullPos);
  }
}
function createTextPayload(text, useUnicode) {
  if (useUnicode) {
    return Buffer.from(text + "\0", "utf16le");
  } else {
    return Buffer.from(text + "\0", "ascii");
  }
}
function getEventNumber(event) {
  const reader = new BinaryReader(event.payload);
  switch (event.kind) {
    case "u8":
      return reader.readU8();
    case "i8":
      return reader.readI8();
    case "u16":
      return reader.readU16LE();
    case "i16":
      return reader.readI16LE();
    case "u32":
      return reader.readU32LE();
    case "i32":
      return reader.readI32LE();
    case "f32":
      return reader.readF32LE();
    default:
      throw new Error(`Cannot get number from ${event.kind} event`);
  }
}
function createNumberPayload(value, kind) {
  const writer = new BinaryWriter();
  switch (kind) {
    case "u8":
      writer.writeU8(value);
      break;
    case "i8":
      writer.writeI8(value);
      break;
    case "u16":
      writer.writeU16LE(value);
      break;
    case "i16":
      writer.writeI16LE(value);
      break;
    case "u32":
      writer.writeU32LE(value);
      break;
    case "i32":
      writer.writeI32LE(value);
      break;
    case "f32":
      writer.writeF32LE(value);
      break;
  }
  return writer.toBuffer();
}

// src/api/ProjectApi.ts
function readProjectMeta(parsed) {
  const titleEvent = findFirstEvent(parsed, EVENT_ID.PROJECT_TITLE);
  const commentsEvent = findFirstEvent(parsed, EVENT_ID.PROJECT_COMMENTS);
  const artistsEvent = findFirstEvent(parsed, EVENT_ID.PROJECT_ARTISTS);
  const genreEvent = findFirstEvent(parsed, EVENT_ID.PROJECT_GENRE);
  const tempoEvent = findFirstEvent(parsed, EVENT_ID.PROJECT_TEMPO);
  return {
    name: titleEvent ? getEventString(titleEvent, parsed.useUnicode) : null,
    description: commentsEvent ? getEventString(commentsEvent, parsed.useUnicode) : null,
    artist: artistsEvent ? getEventString(artistsEvent, parsed.useUnicode) : null,
    genre: genreEvent ? getEventString(genreEvent, parsed.useUnicode) : null,
    bpm: tempoEvent ? getEventNumber(tempoEvent) / 1e3 : null
  };
}
function writeProjectMeta(parsed, meta) {
  return patchEvents(parsed, (event) => {
    if (meta.name !== void 0 && event.id === EVENT_ID.PROJECT_TITLE) {
      return {
        ...event,
        payload: createTextPayload(meta.name ?? "", parsed.useUnicode)
      };
    }
    if (meta.description !== void 0 && event.id === EVENT_ID.PROJECT_COMMENTS) {
      return {
        ...event,
        payload: createTextPayload(meta.description ?? "", parsed.useUnicode)
      };
    }
    if (meta.artist !== void 0 && event.id === EVENT_ID.PROJECT_ARTISTS) {
      return {
        ...event,
        payload: createTextPayload(meta.artist ?? "", parsed.useUnicode)
      };
    }
    if (meta.genre !== void 0 && event.id === EVENT_ID.PROJECT_GENRE) {
      return {
        ...event,
        payload: createTextPayload(meta.genre ?? "", parsed.useUnicode)
      };
    }
    if (meta.bpm && Math.abs(meta.bpm) > 0 && event.id === EVENT_ID.PROJECT_TEMPO) {
      return {
        ...event,
        payload: createNumberPayload(Math.round(Math.abs(meta.bpm) * 1e3), "u32")
      };
    }
    return event;
  });
}
var DELPHI_EPOCH = new Date(1899, 11, 30);
function delphiToDate(days) {
  const ms = days * 24 * 60 * 60 * 1e3;
  return new Date(DELPHI_EPOCH.getTime() + ms);
}
function dateToDelphiDays(date) {
  const ms = date.getTime() - DELPHI_EPOCH.getTime();
  return ms / (24 * 60 * 60 * 1e3);
}
function readProjectTimeInfo(parsed) {
  const timestampEvent = findFirstEvent(parsed, EVENT_ID.PROJECT_TIMESTAMP);
  if (!timestampEvent || timestampEvent.payload.length < 16) {
    return {
      creationDate: null,
      workTimeSeconds: null
    };
  }
  const reader = new BinaryReader(timestampEvent.payload);
  const createdOnDays = reader.readF64LE();
  const timeSpentDays = reader.readF64LE();
  return {
    creationDate: delphiToDate(createdOnDays),
    workTimeSeconds: timeSpentDays * 24 * 60 * 60
    // Convert days to seconds
  };
}
function writeProjectTimeInfo(parsed, info) {
  const current = readProjectTimeInfo(parsed);
  return patchEvents(parsed, (event) => {
    if (event.id !== EVENT_ID.PROJECT_TIMESTAMP) {
      return event;
    }
    const writer = new BinaryWriter();
    if (info.creationDate !== void 0 && info.creationDate !== null) {
      writer.writeF64LE(dateToDelphiDays(info.creationDate));
    } else if (current.creationDate !== null) {
      writer.writeF64LE(dateToDelphiDays(current.creationDate));
    } else {
      writer.writeF64LE(0);
    }
    if (info.workTimeSeconds !== void 0 && info.workTimeSeconds !== null) {
      writer.writeF64LE(info.workTimeSeconds / (24 * 60 * 60));
    } else if (current.workTimeSeconds !== null) {
      writer.writeF64LE(current.workTimeSeconds / (24 * 60 * 60));
    } else {
      writer.writeF64LE(0);
    }
    return {
      ...event,
      payload: writer.toBuffer()
    };
  });
}
function listSamples(parsed) {
  const samples = [];
  parsed.events.forEach((event, index) => {
    if (event.id === EVENT_ID.CHANNEL_SAMPLE_PATH) {
      const path = getEventString(event, parsed.useUnicode);
      if (path && path.length > 0) {
        samples.push({
          eventIndex: index,
          path
        });
      }
    }
  });
  return samples;
}
function rewriteSamplePaths(parsed, mapper) {
  return patchEvents(parsed, (event) => {
    if (event.id !== EVENT_ID.CHANNEL_SAMPLE_PATH) {
      return event;
    }
    const oldPath = getEventString(event, parsed.useUnicode);
    if (!oldPath || oldPath.length === 0) {
      return event;
    }
    const newPath = mapper(oldPath);
    if (newPath === oldPath) {
      return event;
    }
    return {
      ...event,
      payload: createTextPayload(newPath, parsed.useUnicode)
    };
  });
}
var VST_EVENT_ID = {
  MIDI: 1,
  FLAGS: 2,
  IO: 30,
  INPUTS: 31,
  OUTPUTS: 32,
  PLUGIN_INFO: 50,
  FOUR_CC: 51,
  GUID: 52,
  STATE: 53,
  NAME: 54,
  PLUGIN_PATH: 55,
  VENDOR: 56
};
function parseVstPluginData(payload) {
  if (payload.length < 4) {
    return { name: null, vendor: null };
  }
  const reader = new BinaryReader(payload);
  const typeMarker = reader.readU32LE();
  if (typeMarker !== 8 && typeMarker !== 10 && typeMarker !== 11) {
    return { name: null, vendor: null };
  }
  let name = null;
  let vendor = null;
  while (reader.remaining() >= 12) {
    const subEventId = reader.readU32LE();
    const dataSize = reader.readU32LE();
    const dataSizeHigh = reader.readU32LE();
    const actualSize = dataSize + dataSizeHigh * 4294967296;
    if (actualSize > reader.remaining()) {
      break;
    }
    const data = reader.readBytes(actualSize);
    if (subEventId === VST_EVENT_ID.NAME && actualSize > 0) {
      name = data.toString("utf8").replace(/\0/g, "");
    } else if (subEventId === VST_EVENT_ID.VENDOR && actualSize > 0) {
      vendor = data.toString("utf8").replace(/\0/g, "");
    }
  }
  return { name, vendor };
}
function listPlugins(parsed) {
  const plugins = [];
  const seenPlugins = /* @__PURE__ */ new Set();
  let currentInternalName = null;
  let currentPluginName = null;
  for (const event of parsed.events) {
    if (event.id === EVENT_ID.CHANNEL_NEW) {
      if (currentInternalName || currentPluginName) {
        const key = `${currentInternalName ?? ""}:${currentPluginName ?? ""}`;
        if (!seenPlugins.has(key) && currentInternalName && currentInternalName !== "Fruity Wrapper") {
          seenPlugins.add(key);
          plugins.push({
            name: currentPluginName || currentInternalName,
            vendor: null
            // Native plugins don't store vendor
          });
        }
      }
      currentInternalName = null;
      currentPluginName = null;
    }
    if (event.id === EVENT_ID.PLUGIN_INTERNAL_NAME) {
      currentInternalName = getEventString(event, parsed.useUnicode);
    }
    if (event.id === EVENT_ID.PLUGIN_NAME) {
      currentPluginName = getEventString(event, parsed.useUnicode);
    }
    if (event.id === EVENT_ID.PLUGIN_DATA && currentInternalName === "Fruity Wrapper") {
      const vstData = parseVstPluginData(event.payload);
      if (vstData.name) {
        const key = `vst:${vstData.name}:${vstData.vendor ?? ""}`;
        if (!seenPlugins.has(key)) {
          seenPlugins.add(key);
          plugins.push({
            name: vstData.name,
            vendor: vstData.vendor
          });
        }
      }
      currentInternalName = null;
      currentPluginName = null;
    }
  }
  if (currentInternalName && currentInternalName !== "Fruity Wrapper") {
    const key = `${currentInternalName}:${currentPluginName ?? ""}`;
    if (!seenPlugins.has(key)) {
      plugins.push({
        name: currentPluginName || currentInternalName,
        vendor: null
      });
    }
  }
  return plugins;
}
function getFlVersion(parsed) {
  return parsed.flVersion;
}
function getPPQ(parsed) {
  const reader = new BinaryReader(parsed.headerChunkBytes);
  reader.seek(12);
  return reader.readU16LE();
}
export {
  BinaryReader,
  BinaryWriter,
  EVENT_ID,
  EVENT_KIND,
  createEvent,
  createNumberPayload,
  createTextPayload,
  encodeVarInt,
  findEvents,
  findFirstEvent,
  getEventFixedSize,
  getEventKind,
  getEventNumber,
  getEventString,
  getFlVersion,
  getPPQ,
  listPlugins,
  listSamples,
  parseFlp,
  patchEvents,
  readProjectMeta,
  readProjectTimeInfo,
  rewriteSamplePaths,
  serializeFlp,
  varIntSize,
  writeProjectMeta,
  writeProjectTimeInfo
};
//# sourceMappingURL=index.js.map