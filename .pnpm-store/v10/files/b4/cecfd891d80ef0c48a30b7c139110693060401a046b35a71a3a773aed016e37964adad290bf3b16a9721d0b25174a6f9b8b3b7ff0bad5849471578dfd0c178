declare const VERSION_NUMBER = "0.2.1";
declare const PATHSCAN_COMBINED_LOOKUP: number[][][];
declare const SPECPALETTE: {
    r: number;
    g: number;
    b: number;
    a: number;
}[];
declare const GKS: number[][];

interface ImageTracerOptions {
    corsenabled: boolean;
    ltres: number;
    qtres: number;
    pathomit: number;
    rightangleenhance: boolean;
    colorsampling: Colorsampling;
    numberofcolors: number;
    mincolorratio: number;
    colorquantcycles: number;
    layering: number;
    strokewidth: number;
    linefilter: boolean;
    scale: number;
    roundcoords: number;
    viewbox: boolean;
    desc: boolean;
    blurradius: number;
    blurdelta: number;
    layercontainerid?: string;
    lcpr: number;
    qcpr: number;
    pal?: ColorObject[];
}
declare type MaybeImageTracerOptions<T = ImageTracerOptions> = {
    [K in keyof T]?: T[K];
};
declare type ImageTracerOptionsPresetKeys = 'default' | 'posterized1' | 'posterized2' | 'curvy' | 'sharp' | 'detailed' | 'smoothed' | 'grayscale' | 'fixedpalette' | 'randomsampling1' | 'randomsampling2' | 'artistic1' | 'artistic2' | 'artistic3' | 'artistic4' | 'posterized3';
declare type ImageTracerOptionsPresets = {
    [K in ImageTracerOptionsPresetKeys]: K extends 'default' ? ImageTracerOptions : MaybeImageTracerOptions;
};
interface ColorObject {
    r: number;
    g: number;
    b: number;
    a: number;
}
declare enum Colorsampling {
    DISABLED = 0,
    RANDOM_SAMPLING = 1,
    DETERMINISTIC_SAMPLING = 2
}
declare type ImageTracerOptionsParamers = MaybeImageTracerOptions | ImageTracerOptionsPresetKeys | undefined;
interface Tracedata {
    layers: any[];
    palette: any;
    width: number;
    height: number;
}

declare type OptionsString = 'default' | '';
declare class ImageTracer {
    versionnumber: string;
    optionpresets: ImageTracerOptionsPresets;
    /**
     * creating options object, setting defaults for missing values
     * @param options
     */
    checkOptions(options: ImageTracerOptionsParamers): MaybeImageTracerOptions;
    /**
     * Loading an image from a URL, tracing when loaded,
     * then executing callback with the scaled svg string as argument
     * @param url
     * @param callback
     * @param options
     */
    imageToSVG(url: string, options?: ImageTracerOptionsParamers): Promise<string>;
    getImgdata(canvas: HTMLCanvasElement): ImageData;
    /**
     * Helper function: getting ImageData from a canvas
     * @param url
     * @param callback
     * @param options
     */
    loadImage(url: string, options?: MaybeImageTracerOptions): Promise<HTMLCanvasElement>;
    /**
     * Tracing imagedata, then returning the scaled svg string
     * @param imgd
     * @param options
     */
    imageDataToSVG(imgd: ImageData, options?: ImageTracerOptionsParamers): string;
    /**
     * Loading an image from a URL, tracing when loaded,
     * then executing callback with tracedata as argument
     * @param url
     * @param callback
     * @param options
     */
    imageToTracedata(url: string, options?: ImageTracerOptionsParamers): Promise<Tracedata>;
    /**
     * Tracing imagedata, then returning tracedata (layers with paths, palette, image size)
     * @param imgd
     * @param options
     */
    imageDataToTracedata(imgd: ImageData, options?: ImageTracerOptionsParamers): Tracedata;
    /**
     * Helper function: Appending an <svg> element to a container from an svgstring
     * @param svgstr
     * @param parentid
     */
    appendSVGString(svgstr: string, parentid: string): void;
}
declare const imageTracer: ImageTracer;

declare const OPTION_PRESETS: ImageTracerOptionsPresets;

declare function testRightAngle(path: any, idx1: any, idx2: any, idx3: any, idx4: any, idx5: any): boolean;
/**
 * Walking through an edge node array, discarding edge node types 0 and 15 and creating paths from the rest.
 * Walk directions (dir): 0 > ; 1 ^ ; 2 < ; 3 v
 * @param arr
 * @param pathomit
 */
declare function pathScan(arr: any, pathomit: any): any;
/**
 * Batch pathscan
 * @param layers
 * @param pathomit
 */
declare function batchPathScan(layers: any, pathomit: any): any[];
/**
 * recursively trying to fit straight and quadratic spline segments on the 8 direction internode path
 * 1. Find sequences of points with only 2 segment types
 * 2. Fit a straight line on the sequence
 * 3. If the straight line fails (distance error > ltres), find the point with the biggest error
 * 4. Fit a quadratic spline through errorpoint (project this to get controlpoint), then measure errors on every point in the sequence
 * 5. If the spline fails (distance error > qtres), find the point with the biggest error, set splitpoint = fitting point
 * 6. Split sequence and recursively apply 2. - 6. to startpoint-splitpoint and splitpoint-endpoint sequences
 * @param path
 * @param ltres
 * @param qtres
 */
declare function tracePath(path: any, ltres: any, qtres: any): {
    segments: never[];
    boundingbox: any;
    holechildren: any;
    isholepath: any;
};
/**
 * Batch tracing paths
 * @param internodepaths
 * @param ltres
 * @param qtres
 * @returns
 */
declare function batchTracePaths(internodepaths: any, ltres: any, qtres: any): {
    segments: never[];
    boundingbox: any;
    holechildren: any;
    isholepath: any;
}[];

/**
 * Batch interpollation
 * @param bpaths
 * @param options
 */
declare function batchInterNodes(bpaths: any[], options: any): any[];
/**
 * interpollating between path points for nodes with 8 directions ( East, SouthEast, S, SW, W, NW, N, NE )
 * @param paths
 * @param options
 */
declare function interNodes(paths: any, options: any): any;

/**
 * Getting SVG path element string from a traced path
 * @param tracedata
 * @param lnum
 * @param pathnum
 * @param options
 */
declare function svgPathString(tracedata: any, lnum: any, pathnum: any, options: any): string;
/**
 * Convert color object to SVG color string
 * @param c
 * @param options
 * @returns
 */
declare function toSvgColorStr(c: any, options: any): string;
/**
 * 5.2. - 5.6. recursively fitting a straight or quadratic line segment on this sequence of path nodes,
 * called from tracepath()
 * @param path
 * @param ltres
 * @param qtres
 * @param seqstart
 * @param seqend
 * @returns
 */
declare function fitSeq(path: any, ltres: any, qtres: any, seqstart: any, seqend: any): any;
declare function boundingBoxIncludes(parentbbox: number[], childbbox: number[]): boolean;
declare function pointInPoly(p: {
    y: number;
    x: number;
}, pa: string | any[]): boolean;
/**
 * Converting tracedata to an SVG string
 * @param tracedata
 * @param options
 * @returns
 */
declare function getSvgString(tracedata: any, options: any): string;

declare function getDirection(x1: number, y1: number, x2: number, y2: number): number;
/**
 * Rounding to given decimals https://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript
 * @param val
 * @param places
 * @returns
 */
declare const roundToDec: (val: any, places?: any) => number;
/**
 * Color quantization
 * @param imageData
 * @param options
 * @returns
 */
declare function colorQuantization(imageData: ImageData, options: any): {
    array: any[];
    palette: any;
};
/**
 * Convert color object to rgba string
 * @param c
 */
declare const toRgbaStr: (c: any) => string;

/**
 * Batch tracing layers
 * @param binternodes
 * @param ltres
 * @param qtres
 * @returns
 */
declare function batchTraceLayers(binternodes: any[], ltres: any, qtres: any): any[];
/**
 *  Layer separation and edge detection
 * @param ii
 */
declare function layering(ii: any): any[];
/**
 *  Layer separation and edge detection
 * @param ii
 * @param cnum
 */
declare function layeringStep(ii: {
    array: string | any[];
}, cnum: any): any;
/**
 * Helper function: Drawing all edge node layers into a container
 * @param layers
 * @param palette
 * @param scale
 * @param parentid
 */
declare function drawLayers(layers: any[], palette: string | any[], scale: number | undefined, parentid: string): void;

/**
 * Generating a palette with numberofcolors
 * @param numberOfColors
 */
declare function generatePalette(numberOfColors: number): {
    r: number;
    g: number;
    b: number;
    a: number;
}[];
/**
 * Sampling a palette from imagedata
 * @param numberOfColors
 * @param imageData
 */
declare function samplePalette(numberOfColors: number, imageData: ImageData): {
    r: number;
    g: number;
    b: number;
    a: number;
}[];
/**
 * Deterministic sampling a palette from imagedata: rectangular grid
 * @param numberOfColors
 * @param imageData
 */
declare function samplePaletteByGrid(numberOfColors: number, imageData: ImageData): {
    r: number;
    g: number;
    b: number;
    a: number;
}[];

export { ColorObject, Colorsampling, GKS, ImageTracer, ImageTracerOptions, ImageTracerOptionsParamers, ImageTracerOptionsPresetKeys, ImageTracerOptionsPresets, MaybeImageTracerOptions, OPTION_PRESETS, OptionsString, PATHSCAN_COMBINED_LOOKUP, SPECPALETTE, Tracedata, VERSION_NUMBER, batchInterNodes, batchPathScan, batchTraceLayers, batchTracePaths, boundingBoxIncludes, colorQuantization, drawLayers, fitSeq, generatePalette, getDirection, getSvgString, imageTracer, interNodes, layering, layeringStep, pathScan, pointInPoly, roundToDec, samplePalette, samplePaletteByGrid, svgPathString, testRightAngle, toRgbaStr, toSvgColorStr, tracePath };
